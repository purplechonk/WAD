{
  "version": 3,
  "sources": ["../../@motionone/utils/dist/array.es.js", "../../@motionone/utils/dist/clamp.es.js", "../../@motionone/utils/dist/defaults.es.js", "../../@motionone/utils/dist/is-number.es.js", "../../@motionone/utils/dist/is-easing-list.es.js", "../../@motionone/utils/dist/wrap.es.js", "../../@motionone/utils/dist/easing.es.js", "../../@motionone/utils/dist/mix.es.js", "../../@motionone/utils/dist/noop.es.js", "../../@motionone/utils/dist/progress.es.js", "../../@motionone/utils/dist/offset.es.js", "../../@motionone/utils/dist/interpolate.es.js", "../../@motionone/utils/dist/is-cubic-bezier.es.js", "../../@motionone/utils/dist/is-easing-generator.es.js", "../../@motionone/utils/dist/is-function.es.js", "../../@motionone/utils/dist/is-string.es.js", "../../@motionone/utils/dist/time.es.js", "../../@motionone/utils/dist/velocity.es.js", "../../@motionone/easing/dist/cubic-bezier.es.js", "../../@motionone/easing/dist/steps.es.js", "../../@motionone/animation/dist/utils/easing.es.js", "../../@motionone/animation/dist/Animation.es.js", "../../hey-listen/dist/hey-listen.es.js", "../../@motionone/types/dist/MotionValue.es.js", "../../@motionone/dom/dist/animate/data.es.js", "../../@motionone/dom/dist/animate/utils/transforms.es.js", "../../@motionone/dom/dist/animate/utils/css-var.es.js", "../../@motionone/dom/dist/animate/utils/feature-detection.es.js", "../../@motionone/dom/dist/animate/utils/easing.es.js", "../../@motionone/dom/dist/animate/utils/keyframes.es.js", "../../@motionone/dom/dist/animate/utils/get-style-name.es.js", "../../@motionone/dom/dist/animate/style.es.js", "../../@motionone/dom/dist/animate/utils/stop-animation.es.js", "../../@motionone/dom/dist/animate/utils/get-unit.es.js", "../../@motionone/dom/dist/animate/animate-style.es.js", "../../@motionone/dom/dist/animate/utils/options.es.js", "../../@motionone/dom/dist/utils/resolve-elements.es.js", "../../@motionone/dom/dist/animate/utils/controls.es.js", "../../@motionone/dom/dist/utils/stagger.es.js", "../../@motionone/dom/dist/animate/create-animate.es.js", "../../@motionone/dom/dist/animate/index.es.js", "../../@motionone/dom/dist/timeline/utils/calc-time.es.js", "../../@motionone/dom/dist/timeline/utils/edit.es.js", "../../@motionone/dom/dist/timeline/utils/sort.es.js", "../../@motionone/dom/dist/timeline/index.es.js", "../../@motionone/generators/dist/utils/velocity.es.js", "../../@motionone/generators/dist/spring/defaults.es.js", "../../@motionone/generators/dist/spring/utils.es.js", "../../@motionone/generators/dist/utils/has-reached-target.es.js", "../../@motionone/generators/dist/spring/index.es.js", "../../@motionone/generators/dist/glide/index.es.js", "../../@motionone/generators/dist/utils/pregenerate-keyframes.es.js", "../../@motionone/dom/dist/easing/create-generator-easing.es.js", "../../@motionone/dom/dist/easing/spring/index.es.js", "../../@motionone/dom/dist/easing/glide/index.es.js", "../../@motionone/dom/dist/gestures/in-view.es.js", "../../@motionone/dom/dist/gestures/resize/handle-element.es.js", "../../@motionone/dom/dist/gestures/resize/handle-window.es.js", "../../@motionone/dom/dist/gestures/resize/index.es.js", "../../@motionone/dom/dist/gestures/scroll/info.es.js", "../../@motionone/dom/dist/gestures/scroll/offsets/inset.es.js", "../../@motionone/dom/dist/gestures/scroll/offsets/presets.es.js", "../../@motionone/dom/dist/gestures/scroll/offsets/edge.es.js", "../../@motionone/dom/dist/gestures/scroll/offsets/offset.es.js", "../../@motionone/dom/dist/gestures/scroll/offsets/index.es.js", "../../@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js", "../../@motionone/dom/dist/gestures/scroll/index.es.js", "../../@motionone/dom/dist/state/utils/has-changed.es.js", "../../@motionone/dom/dist/state/utils/is-variant.es.js", "../../@motionone/dom/dist/state/utils/resolve-variant.es.js", "../../@motionone/dom/dist/state/utils/schedule.es.js", "../../@motionone/dom/dist/state/utils/events.es.js", "../../@motionone/dom/dist/state/gestures/in-view.es.js", "../../@motionone/dom/dist/state/gestures/hover.es.js", "../../@motionone/dom/dist/state/gestures/press.es.js", "../../@motionone/dom/dist/state/index.es.js", "../../@motionone/dom/dist/animate/utils/style-object.es.js", "../../@motionone/dom/dist/animate/utils/style-string.es.js", "../../motion/dist/animate.es.js"],
  "sourcesContent": ["function addUniqueItem(array, item) {\r\n    array.indexOf(item) === -1 && array.push(item);\r\n}\r\nfunction removeItem(arr, item) {\r\n    const index = arr.indexOf(item);\r\n    index > -1 && arr.splice(index, 1);\r\n}\r\n\r\nexport { addUniqueItem, removeItem };\r\n", "const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\r\n\r\nexport { clamp };\r\n", "const defaults = {\r\n    duration: 0.3,\r\n    delay: 0,\r\n    endDelay: 0,\r\n    repeat: 0,\r\n    easing: \"ease\",\r\n};\r\n\r\nexport { defaults };\r\n", "const isNumber = (value) => typeof value === \"number\";\r\n\r\nexport { isNumber };\r\n", "import { isNumber } from './is-number.es.js';\r\n\r\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\r\n\r\nexport { isEasingList };\r\n", "const wrap = (min, max, v) => {\r\n    const rangeSize = max - min;\r\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\r\n};\r\n\r\nexport { wrap };\r\n", "import { isEasingList } from './is-easing-list.es.js';\r\nimport { wrap } from './wrap.es.js';\r\n\r\nfunction getEasingForSegment(easing, i) {\r\n    return isEasingList(easing) ? easing[wrap(0, easing.length, i)] : easing;\r\n}\r\n\r\nexport { getEasingForSegment };\r\n", "const mix = (min, max, progress) => -progress * min + progress * max + min;\r\n\r\nexport { mix };\r\n", "const noop = () => { };\r\nconst noopReturn = (v) => v;\r\n\r\nexport { noop, noopReturn };\r\n", "const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\r\n\r\nexport { progress };\r\n", "import { mix } from './mix.es.js';\r\nimport { progress } from './progress.es.js';\r\n\r\nfunction fillOffset(offset, remaining) {\r\n    const min = offset[offset.length - 1];\r\n    for (let i = 1; i <= remaining; i++) {\r\n        const offsetProgress = progress(0, remaining, i);\r\n        offset.push(mix(min, 1, offsetProgress));\r\n    }\r\n}\r\nfunction defaultOffset(length) {\r\n    const offset = [0];\r\n    fillOffset(offset, length - 1);\r\n    return offset;\r\n}\r\n\r\nexport { defaultOffset, fillOffset };\r\n", "import { mix } from './mix.es.js';\r\nimport { noopReturn } from './noop.es.js';\r\nimport { fillOffset, defaultOffset } from './offset.es.js';\r\nimport { progress } from './progress.es.js';\r\nimport { getEasingForSegment } from './easing.es.js';\r\nimport { clamp } from './clamp.es.js';\r\n\r\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\r\n    const length = output.length;\r\n    /**\r\n     * If the input length is lower than the output we\r\n     * fill the input to match. This currently assumes the input\r\n     * is an animation progress value so is a good candidate for\r\n     * moving outside the function.\r\n     */\r\n    const remainder = length - input.length;\r\n    remainder > 0 && fillOffset(input, remainder);\r\n    return (t) => {\r\n        let i = 0;\r\n        for (; i < length - 2; i++) {\r\n            if (t < input[i + 1])\r\n                break;\r\n        }\r\n        let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));\r\n        const segmentEasing = getEasingForSegment(easing, i);\r\n        progressInRange = segmentEasing(progressInRange);\r\n        return mix(output[i], output[i + 1], progressInRange);\r\n    };\r\n}\r\n\r\nexport { interpolate };\r\n", "import { isNumber } from './is-number.es.js';\r\n\r\nconst isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);\r\n\r\nexport { isCubicBezier };\r\n", "const isEasingGenerator = (easing) => typeof easing === \"object\" &&\r\n    Boolean(easing.createAnimation);\r\n\r\nexport { isEasingGenerator };\r\n", "const isFunction = (value) => typeof value === \"function\";\r\n\r\nexport { isFunction };\r\n", "const isString = (value) => typeof value === \"string\";\r\n\r\nexport { isString };\r\n", "const time = {\r\n    ms: (seconds) => seconds * 1000,\r\n    s: (milliseconds) => milliseconds / 1000,\r\n};\r\n\r\nexport { time };\r\n", "/*\r\n  Convert velocity into velocity per second\r\n\r\n  @param [number]: Unit per frame\r\n  @param [number]: Frame duration in ms\r\n*/\r\nfunction velocityPerSecond(velocity, frameDuration) {\r\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\r\n}\r\n\r\nexport { velocityPerSecond };\r\n", "import { noopReturn } from '@motionone/utils';\r\n\r\n/*\r\n  Bezier function generator\r\n\r\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\r\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\r\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\r\n  \r\n  I've removed the newtonRaphsonIterate algo because in benchmarking it\r\n  wasn't noticiably faster than binarySubdivision, indeed removing it\r\n  usually improved times, depending on the curve.\r\n\r\n  I also removed the lookup table, as for the added bundle size and loop we're\r\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\r\n  to 12 to compensate and this still tended to be faster for no perceivable\r\n  loss in accuracy.\r\n\r\n  Usage\r\n    const easeOut = cubicBezier(.17,.67,.83,.67);\r\n    const x = easeOut(0.5); // returns 0.627...\r\n*/\r\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\r\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\r\nconst subdivisionPrecision = 0.0000001;\r\nconst subdivisionMaxIterations = 12;\r\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\r\n    let currentX;\r\n    let currentT;\r\n    let i = 0;\r\n    do {\r\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\r\n        currentX = calcBezier(currentT, mX1, mX2) - x;\r\n        if (currentX > 0.0) {\r\n            upperBound = currentT;\r\n        }\r\n        else {\r\n            lowerBound = currentT;\r\n        }\r\n    } while (Math.abs(currentX) > subdivisionPrecision &&\r\n        ++i < subdivisionMaxIterations);\r\n    return currentT;\r\n}\r\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\r\n    // If this is a linear gradient, return linear easing\r\n    if (mX1 === mY1 && mX2 === mY2)\r\n        return noopReturn;\r\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\r\n    // If animation is at start/end, return t without easing\r\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\r\n}\r\n\r\nexport { cubicBezier };\r\n", "import { clamp } from '@motionone/utils';\r\n\r\nconst steps = (steps, direction = \"end\") => (progress) => {\r\n    progress =\r\n        direction === \"end\"\r\n            ? Math.min(progress, 0.999)\r\n            : Math.max(progress, 0.001);\r\n    const expanded = progress * steps;\r\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\r\n    return clamp(0, 1, rounded / steps);\r\n};\r\n\r\nexport { steps };\r\n", "import { cubicBezier, steps } from '@motionone/easing';\r\nimport { isFunction, isCubicBezier, noopReturn } from '@motionone/utils';\r\n\r\nconst namedEasings = {\r\n    ease: cubicBezier(0.25, 0.1, 0.25, 1.0),\r\n    \"ease-in\": cubicBezier(0.42, 0.0, 1.0, 1.0),\r\n    \"ease-in-out\": cubicBezier(0.42, 0.0, 0.58, 1.0),\r\n    \"ease-out\": cubicBezier(0.0, 0.0, 0.58, 1.0),\r\n};\r\nconst functionArgsRegex = /\\((.*?)\\)/;\r\nfunction getEasingFunction(definition) {\r\n    // If already an easing function, return\r\n    if (isFunction(definition))\r\n        return definition;\r\n    // If an easing curve definition, return bezier function\r\n    if (isCubicBezier(definition))\r\n        return cubicBezier(...definition);\r\n    // If we have a predefined easing function, return\r\n    const namedEasing = namedEasings[definition];\r\n    if (namedEasing)\r\n        return namedEasing;\r\n    // If this is a steps function, attempt to create easing curve\r\n    if (definition.startsWith(\"steps\")) {\r\n        const args = functionArgsRegex.exec(definition);\r\n        if (args) {\r\n            const argsArray = args[1].split(\",\");\r\n            return steps(parseFloat(argsArray[0]), argsArray[1].trim());\r\n        }\r\n    }\r\n    return noopReturn;\r\n}\r\n\r\nexport { getEasingFunction };\r\n", "import { noopReturn, defaults, isEasingGenerator, isEasingList, interpolate } from '@motionone/utils';\r\nimport { getEasingFunction } from './utils/easing.es.js';\r\n\r\nclass Animation {\r\n    constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", autoplay = true, } = {}) {\r\n        this.startTime = null;\r\n        this.rate = 1;\r\n        this.t = 0;\r\n        this.cancelTimestamp = null;\r\n        this.easing = noopReturn;\r\n        this.duration = 0;\r\n        this.totalDuration = 0;\r\n        this.repeat = 0;\r\n        this.playState = \"idle\";\r\n        this.finished = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n        easing = easing || defaults.easing;\r\n        if (isEasingGenerator(easing)) {\r\n            const custom = easing.createAnimation(keyframes);\r\n            easing = custom.easing;\r\n            keyframes = custom.keyframes || keyframes;\r\n            initialDuration = custom.duration || initialDuration;\r\n        }\r\n        this.repeat = repeat;\r\n        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);\r\n        this.updateDuration(initialDuration);\r\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);\r\n        this.tick = (timestamp) => {\r\n            var _a;\r\n            // TODO: Temporary fix for OptionsResolver typing\r\n            delay = delay;\r\n            let t = 0;\r\n            if (this.pauseTime !== undefined) {\r\n                t = this.pauseTime;\r\n            }\r\n            else {\r\n                t = (timestamp - this.startTime) * this.rate;\r\n            }\r\n            this.t = t;\r\n            // Convert to seconds\r\n            t /= 1000;\r\n            // Rebase on delay\r\n            t = Math.max(t - delay, 0);\r\n            /**\r\n             * If this animation has finished, set the current time\r\n             * to the total duration.\r\n             */\r\n            if (this.playState === \"finished\" && this.pauseTime === undefined) {\r\n                t = this.totalDuration;\r\n            }\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = t / this.duration;\r\n            // TODO progress += iterationStart\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            iterationProgress === 1 && currentIteration--;\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const iterationIsOdd = currentIteration % 2;\r\n            if (direction === \"reverse\" ||\r\n                (direction === \"alternate\" && iterationIsOdd) ||\r\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\r\n                iterationProgress = 1 - iterationProgress;\r\n            }\r\n            const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);\r\n            const latest = interpolate$1(this.easing(p));\r\n            output(latest);\r\n            const isAnimationFinished = this.pauseTime === undefined &&\r\n                (this.playState === \"finished\" || t >= this.totalDuration + endDelay);\r\n            if (isAnimationFinished) {\r\n                this.playState = \"finished\";\r\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\r\n            }\r\n            else if (this.playState !== \"idle\") {\r\n                this.frameRequestId = requestAnimationFrame(this.tick);\r\n            }\r\n        };\r\n        if (autoplay)\r\n            this.play();\r\n    }\r\n    play() {\r\n        const now = performance.now();\r\n        this.playState = \"running\";\r\n        if (this.pauseTime !== undefined) {\r\n            this.startTime = now - this.pauseTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = now;\r\n        }\r\n        this.cancelTimestamp = this.startTime;\r\n        this.pauseTime = undefined;\r\n        this.frameRequestId = requestAnimationFrame(this.tick);\r\n    }\r\n    pause() {\r\n        this.playState = \"paused\";\r\n        this.pauseTime = this.t;\r\n    }\r\n    finish() {\r\n        this.playState = \"finished\";\r\n        this.tick(0);\r\n    }\r\n    stop() {\r\n        var _a;\r\n        this.playState = \"idle\";\r\n        if (this.frameRequestId !== undefined) {\r\n            cancelAnimationFrame(this.frameRequestId);\r\n        }\r\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\r\n    }\r\n    cancel() {\r\n        this.stop();\r\n        this.tick(this.cancelTimestamp);\r\n    }\r\n    reverse() {\r\n        this.rate *= -1;\r\n    }\r\n    commitStyles() { }\r\n    updateDuration(duration) {\r\n        this.duration = duration;\r\n        this.totalDuration = duration * (this.repeat + 1);\r\n    }\r\n    get currentTime() {\r\n        return this.t;\r\n    }\r\n    set currentTime(t) {\r\n        if (this.pauseTime !== undefined || this.rate === 0) {\r\n            this.pauseTime = t;\r\n        }\r\n        else {\r\n            this.startTime = performance.now() - t / this.rate;\r\n        }\r\n    }\r\n    get playbackRate() {\r\n        return this.rate;\r\n    }\r\n    set playbackRate(rate) {\r\n        this.rate = rate;\r\n    }\r\n}\r\n\r\nexport { Animation };\r\n", "var warning = function () { };\r\nvar invariant = function () { };\r\nif (process.env.NODE_ENV !== 'production') {\r\n    warning = function (check, message) {\r\n        if (!check && typeof console !== 'undefined') {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = function (check, message) {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\r\n\r\nexport { invariant, warning };\r\n", "/**\r\n * The MotionValue tracks the state of a single animatable\r\n * value. Currently, updatedAt and current are unused. The\r\n * long term idea is to use this to minimise the number\r\n * of DOM reads, and to abstract the DOM interactions here.\r\n */\r\nclass MotionValue {\r\n    setAnimation(animation) {\r\n        this.animation = animation;\r\n        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });\r\n    }\r\n    clearAnimation() {\r\n        this.animation = this.generator = undefined;\r\n    }\r\n}\r\n\r\nexport { MotionValue };\r\n", "import { MotionValue } from '@motionone/types';\r\n\r\nconst data = new WeakMap();\r\nfunction getAnimationData(element) {\r\n    if (!data.has(element)) {\r\n        data.set(element, {\r\n            transforms: [],\r\n            values: new Map(),\r\n        });\r\n    }\r\n    return data.get(element);\r\n}\r\nfunction getMotionValue(motionValues, name) {\r\n    if (!motionValues.has(name)) {\r\n        motionValues.set(name, new MotionValue());\r\n    }\r\n    return motionValues.get(name);\r\n}\r\n\r\nexport { getAnimationData, getMotionValue };\r\n", "import { noopReturn, addUniqueItem } from '@motionone/utils';\r\nimport { getAnimationData } from '../data.es.js';\r\n\r\n/**\r\n * A list of all transformable axes. We'll use this list to generated a version\r\n * of each axes for each transform.\r\n */\r\nconst axes = [\"\", \"X\", \"Y\", \"Z\"];\r\n/**\r\n * An ordered array of each transformable value. By default, transform values\r\n * will be sorted to this order.\r\n */\r\nconst order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\r\nconst transformAlias = {\r\n    x: \"translateX\",\r\n    y: \"translateY\",\r\n    z: \"translateZ\",\r\n};\r\nconst rotation = {\r\n    syntax: \"<angle>\",\r\n    initialValue: \"0deg\",\r\n    toDefaultUnit: (v) => v + \"deg\",\r\n};\r\nconst baseTransformProperties = {\r\n    translate: {\r\n        syntax: \"<length-percentage>\",\r\n        initialValue: \"0px\",\r\n        toDefaultUnit: (v) => v + \"px\",\r\n    },\r\n    rotate: rotation,\r\n    scale: {\r\n        syntax: \"<number>\",\r\n        initialValue: 1,\r\n        toDefaultUnit: noopReturn,\r\n    },\r\n    skew: rotation,\r\n};\r\nconst transformDefinitions = new Map();\r\nconst asTransformCssVar = (name) => `--motion-${name}`;\r\n/**\r\n * Generate a list of every possible transform key\r\n */\r\nconst transforms = [\"x\", \"y\", \"z\"];\r\norder.forEach((name) => {\r\n    axes.forEach((axis) => {\r\n        transforms.push(name + axis);\r\n        transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);\r\n    });\r\n});\r\n/**\r\n * A function to use with Array.sort to sort transform keys by their default order.\r\n */\r\nconst compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);\r\n/**\r\n * Provide a quick way to check if a string is the name of a transform\r\n */\r\nconst transformLookup = new Set(transforms);\r\nconst isTransform = (name) => transformLookup.has(name);\r\nconst addTransformToElement = (element, name) => {\r\n    // Map x to translateX etc\r\n    if (transformAlias[name])\r\n        name = transformAlias[name];\r\n    const { transforms } = getAnimationData(element);\r\n    addUniqueItem(transforms, name);\r\n    /**\r\n     * TODO: An optimisation here could be to cache the transform in element data\r\n     * and only update if this has changed.\r\n     */\r\n    element.style.transform = buildTransformTemplate(transforms);\r\n};\r\nconst buildTransformTemplate = (transforms) => transforms\r\n    .sort(compareTransformOrder)\r\n    .reduce(transformListToString, \"\")\r\n    .trim();\r\nconst transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;\r\n\r\nexport { addTransformToElement, asTransformCssVar, axes, buildTransformTemplate, compareTransformOrder, isTransform, transformAlias, transformDefinitions };\r\n", "import { transformDefinitions } from './transforms.es.js';\r\n\r\nconst isCssVar = (name) => name.startsWith(\"--\");\r\nconst registeredProperties = new Set();\r\nfunction registerCssVariable(name) {\r\n    if (registeredProperties.has(name))\r\n        return;\r\n    registeredProperties.add(name);\r\n    try {\r\n        const { syntax, initialValue } = transformDefinitions.has(name)\r\n            ? transformDefinitions.get(name)\r\n            : {};\r\n        CSS.registerProperty({\r\n            name,\r\n            inherits: false,\r\n            syntax,\r\n            initialValue,\r\n        });\r\n    }\r\n    catch (e) { }\r\n}\r\n\r\nexport { isCssVar, registerCssVariable, registeredProperties };\r\n", "const testAnimation = (keyframes, options) => document.createElement(\"div\").animate(keyframes, options);\r\nconst featureTests = {\r\n    cssRegisterProperty: () => typeof CSS !== \"undefined\" &&\r\n        Object.hasOwnProperty.call(CSS, \"registerProperty\"),\r\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\r\n    partialKeyframes: () => {\r\n        try {\r\n            testAnimation({ opacity: [1] });\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 0.001 }).finished),\r\n    linearEasing: () => {\r\n        try {\r\n            testAnimation({ opacity: 0 }, { easing: \"linear(0, 1)\" });\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n};\r\nconst results = {};\r\nconst supports = {};\r\nfor (const key in featureTests) {\r\n    supports[key] = () => {\r\n        if (results[key] === undefined)\r\n            results[key] =\r\n                featureTests[key]();\r\n        return results[key];\r\n    };\r\n}\r\n\r\nexport { supports };\r\n", "import { isFunction, defaults, isCubicBezier, progress } from '@motionone/utils';\r\nimport { supports } from './feature-detection.es.js';\r\n\r\n// Create a linear easing point for every x second\r\nconst resolution = 0.015;\r\nconst generateLinearEasingPoints = (easing, duration) => {\r\n    let points = \"\";\r\n    const numPoints = Math.round(duration / resolution);\r\n    for (let i = 0; i < numPoints; i++) {\r\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\r\n    }\r\n    return points.substring(0, points.length - 2);\r\n};\r\nconst convertEasing = (easing, duration) => {\r\n    if (isFunction(easing)) {\r\n        return supports.linearEasing()\r\n            ? `linear(${generateLinearEasingPoints(easing, duration)})`\r\n            : defaults.easing;\r\n    }\r\n    else {\r\n        return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\r\n    }\r\n};\r\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\r\n\r\nexport { convertEasing, cubicBezierAsString, generateLinearEasingPoints };\r\n", "function hydrateKeyframes(keyframes, readInitialValue) {\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        if (keyframes[i] === null) {\r\n            keyframes[i] = i ? keyframes[i - 1] : readInitialValue();\r\n        }\r\n    }\r\n    return keyframes;\r\n}\r\nconst keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];\r\n\r\nexport { hydrateKeyframes, keyframesList };\r\n", "import { isTransform, asTransformCssVar, transformAlias } from './transforms.es.js';\r\n\r\nfunction getStyleName(key) {\r\n    if (transformAlias[key])\r\n        key = transformAlias[key];\r\n    return isTransform(key) ? asTransformCssVar(key) : key;\r\n}\r\n\r\nexport { getStyleName };\r\n", "import { isCssVar } from './utils/css-var.es.js';\r\nimport { getStyleName } from './utils/get-style-name.es.js';\r\nimport { transformDefinitions } from './utils/transforms.es.js';\r\n\r\nconst style = {\r\n    get: (element, name) => {\r\n        name = getStyleName(name);\r\n        let value = isCssVar(name)\r\n            ? element.style.getPropertyValue(name)\r\n            : getComputedStyle(element)[name];\r\n        // TODO Decide if value can be 0\r\n        if (!value && value !== 0) {\r\n            const definition = transformDefinitions.get(name);\r\n            if (definition)\r\n                value = definition.initialValue;\r\n        }\r\n        return value;\r\n    },\r\n    set: (element, name, value) => {\r\n        name = getStyleName(name);\r\n        if (isCssVar(name)) {\r\n            element.style.setProperty(name, value);\r\n        }\r\n        else {\r\n            element.style[name] = value;\r\n        }\r\n    },\r\n};\r\n\r\nexport { style };\r\n", "function stopAnimation(animation, needsCommit = true) {\r\n    if (!animation || animation.playState === \"finished\")\r\n        return;\r\n    // Suppress error thrown by WAAPI\r\n    try {\r\n        if (animation.stop) {\r\n            animation.stop();\r\n        }\r\n        else {\r\n            needsCommit && animation.commitStyles();\r\n            animation.cancel();\r\n        }\r\n    }\r\n    catch (e) { }\r\n}\r\n\r\nexport { stopAnimation };\r\n", "import { noopReturn, isString } from '@motionone/utils';\r\n\r\nfunction getUnitConverter(keyframes, definition) {\r\n    var _a;\r\n    let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;\r\n    const finalKeyframe = keyframes[keyframes.length - 1];\r\n    if (isString(finalKeyframe)) {\r\n        const unit = ((_a = finalKeyframe.match(/(-?[\\d.]+)([a-z%]*)/)) === null || _a === void 0 ? void 0 : _a[2]) || \"\";\r\n        if (unit)\r\n            toUnit = (value) => value + unit;\r\n    }\r\n    return toUnit;\r\n}\r\n\r\nexport { getUnitConverter };\r\n", "import { getAnimationData, getMotionValue } from './data.es.js';\r\nimport { isCssVar, registerCssVariable } from './utils/css-var.es.js';\r\nimport { defaults, isEasingGenerator, isFunction, isEasingList, isNumber, time, noop } from '@motionone/utils';\r\nimport { isTransform, addTransformToElement, transformDefinitions } from './utils/transforms.es.js';\r\nimport { convertEasing } from './utils/easing.es.js';\r\nimport { supports } from './utils/feature-detection.es.js';\r\nimport { hydrateKeyframes, keyframesList } from './utils/keyframes.es.js';\r\nimport { style } from './style.es.js';\r\nimport { getStyleName } from './utils/get-style-name.es.js';\r\nimport { stopAnimation } from './utils/stop-animation.es.js';\r\nimport { getUnitConverter } from './utils/get-unit.es.js';\r\n\r\nfunction getDevToolsRecord() {\r\n    return window.__MOTION_DEV_TOOLS_RECORD;\r\n}\r\nfunction animateStyle(element, key, keyframesDefinition, options = {}, AnimationPolyfill) {\r\n    const record = getDevToolsRecord();\r\n    const isRecording = options.record !== false && record;\r\n    let animation;\r\n    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist = false, direction, offset, allowWebkitAcceleration = false, autoplay = true, } = options;\r\n    const data = getAnimationData(element);\r\n    const valueIsTransform = isTransform(key);\r\n    let canAnimateNatively = supports.waapi();\r\n    /**\r\n     * If this is an individual transform, we need to map its\r\n     * key to a CSS variable and update the element's transform style\r\n     */\r\n    valueIsTransform && addTransformToElement(element, key);\r\n    const name = getStyleName(key);\r\n    const motionValue = getMotionValue(data.values, name);\r\n    /**\r\n     * Get definition of value, this will be used to convert numerical\r\n     * keyframes into the default value type.\r\n     */\r\n    const definition = transformDefinitions.get(name);\r\n    /**\r\n     * Stop the current animation, if any. Because this will trigger\r\n     * commitStyles (DOM writes) and we might later trigger DOM reads,\r\n     * this is fired now and we return a factory function to create\r\n     * the actual animation that can get called in batch,\r\n     */\r\n    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&\r\n        options.record !== false);\r\n    /**\r\n     * Batchable factory function containing all DOM reads.\r\n     */\r\n    return () => {\r\n        const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };\r\n        /**\r\n         * Replace null values with the previous keyframe value, or read\r\n         * it from the DOM if it's the first keyframe.\r\n         */\r\n        let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);\r\n        /**\r\n         * Detect unit type of keyframes.\r\n         */\r\n        const toUnit = getUnitConverter(keyframes, definition);\r\n        if (isEasingGenerator(easing)) {\r\n            const custom = easing.createAnimation(keyframes, key !== \"opacity\", readInitialValue, name, motionValue);\r\n            easing = custom.easing;\r\n            keyframes = custom.keyframes || keyframes;\r\n            duration = custom.duration || duration;\r\n        }\r\n        /**\r\n         * If this is a CSS variable we need to register it with the browser\r\n         * before it can be animated natively. We also set it with setProperty\r\n         * rather than directly onto the element.style object.\r\n         */\r\n        if (isCssVar(name)) {\r\n            if (supports.cssRegisterProperty()) {\r\n                registerCssVariable(name);\r\n            }\r\n            else {\r\n                canAnimateNatively = false;\r\n            }\r\n        }\r\n        /**\r\n         * If we've been passed a custom easing function, and this browser\r\n         * does **not** support linear() easing, and the value is a transform\r\n         * (and thus a pure number) we can still support the custom easing\r\n         * by falling back to the animation polyfill.\r\n         */\r\n        if (valueIsTransform &&\r\n            !supports.linearEasing() &&\r\n            (isFunction(easing) || (isEasingList(easing) && easing.some(isFunction)))) {\r\n            canAnimateNatively = false;\r\n        }\r\n        /**\r\n         * If we can animate this value with WAAPI, do so.\r\n         */\r\n        if (canAnimateNatively) {\r\n            /**\r\n             * Convert numbers to default value types. Currently this only supports\r\n             * transforms but it could also support other value types.\r\n             */\r\n            if (definition) {\r\n                keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);\r\n            }\r\n            /**\r\n             * If this browser doesn't support partial/implicit keyframes we need to\r\n             * explicitly provide one.\r\n             */\r\n            if (keyframes.length === 1 &&\r\n                (!supports.partialKeyframes() || isRecording)) {\r\n                keyframes.unshift(readInitialValue());\r\n            }\r\n            const animationOptions = {\r\n                delay: time.ms(delay),\r\n                duration: time.ms(duration),\r\n                endDelay: time.ms(endDelay),\r\n                easing: !isEasingList(easing)\r\n                    ? convertEasing(easing, duration)\r\n                    : undefined,\r\n                direction,\r\n                iterations: repeat + 1,\r\n                fill: \"both\",\r\n            };\r\n            animation = element.animate({\r\n                [name]: keyframes,\r\n                offset,\r\n                easing: isEasingList(easing)\r\n                    ? easing.map((thisEasing) => convertEasing(thisEasing, duration))\r\n                    : undefined,\r\n            }, animationOptions);\r\n            /**\r\n             * Polyfill finished Promise in browsers that don't support it\r\n             */\r\n            if (!animation.finished) {\r\n                animation.finished = new Promise((resolve, reject) => {\r\n                    animation.onfinish = resolve;\r\n                    animation.oncancel = reject;\r\n                });\r\n            }\r\n            const target = keyframes[keyframes.length - 1];\r\n            animation.finished\r\n                .then(() => {\r\n                if (persist)\r\n                    return;\r\n                // Apply styles to target\r\n                style.set(element, name, target);\r\n                // Ensure fill modes don't persist\r\n                animation.cancel();\r\n            })\r\n                .catch(noop);\r\n            /**\r\n             * This forces Webkit to run animations on the main thread by exploiting\r\n             * this condition:\r\n             * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099\r\n             *\r\n             * This fixes Webkit's timing bugs, like accelerated animations falling\r\n             * out of sync with main thread animations and massive delays in starting\r\n             * accelerated animations in WKWebView.\r\n             */\r\n            if (!allowWebkitAcceleration)\r\n                animation.playbackRate = 1.000001;\r\n            /**\r\n             * If we can't animate the value natively then we can fallback to the numbers-only\r\n             * polyfill for transforms.\r\n             */\r\n        }\r\n        else if (AnimationPolyfill && valueIsTransform) {\r\n            /**\r\n             * If any keyframe is a string (because we measured it from the DOM), we need to convert\r\n             * it into a number before passing to the Animation polyfill.\r\n             */\r\n            keyframes = keyframes.map((value) => typeof value === \"string\" ? parseFloat(value) : value);\r\n            /**\r\n             * If we only have a single keyframe, we need to create an initial keyframe by reading\r\n             * the current value from the DOM.\r\n             */\r\n            if (keyframes.length === 1) {\r\n                keyframes.unshift(parseFloat(readInitialValue()));\r\n            }\r\n            animation = new AnimationPolyfill((latest) => {\r\n                style.set(element, name, toUnit ? toUnit(latest) : latest);\r\n            }, keyframes, Object.assign(Object.assign({}, options), { duration,\r\n                easing }));\r\n        }\r\n        else {\r\n            const target = keyframes[keyframes.length - 1];\r\n            style.set(element, name, definition && isNumber(target)\r\n                ? definition.toDefaultUnit(target)\r\n                : target);\r\n        }\r\n        if (isRecording) {\r\n            record(element, key, keyframes, {\r\n                duration,\r\n                delay: delay,\r\n                easing,\r\n                repeat,\r\n                offset,\r\n            }, \"motion-one\");\r\n        }\r\n        motionValue.setAnimation(animation);\r\n        if (animation && !autoplay)\r\n            animation.pause();\r\n        return animation;\r\n    };\r\n}\r\n\r\nexport { animateStyle };\r\n", "const getOptions = (options, key) => \r\n/**\r\n * TODO: Make test for this\r\n * Always return a new object otherwise delay is overwritten by results of stagger\r\n * and this results in no stagger\r\n */\r\noptions[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);\r\n\r\nexport { getOptions };\r\n", "function resolveElements(elements, selectorCache) {\r\n    var _a;\r\n    if (typeof elements === \"string\") {\r\n        if (selectorCache) {\r\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\r\n            elements = selectorCache[elements];\r\n        }\r\n        else {\r\n            elements = document.querySelectorAll(elements);\r\n        }\r\n    }\r\n    else if (elements instanceof Element) {\r\n        elements = [elements];\r\n    }\r\n    /**\r\n     * Return an empty array\r\n     */\r\n    return Array.from(elements || []);\r\n}\r\n\r\nexport { resolveElements };\r\n", "import { defaults, noop, time } from '@motionone/utils';\r\nimport { stopAnimation } from './stop-animation.es.js';\r\n\r\nconst createAnimation = (factory) => factory();\r\nconst withControls = (animationFactory, options, duration = defaults.duration) => {\r\n    return new Proxy({\r\n        animations: animationFactory.map(createAnimation).filter(Boolean),\r\n        duration,\r\n        options,\r\n    }, controls);\r\n};\r\n/**\r\n * TODO:\r\n * Currently this returns the first animation, ideally it would return\r\n * the first active animation.\r\n */\r\nconst getActiveAnimation = (state) => state.animations[0];\r\nconst controls = {\r\n    get: (target, key) => {\r\n        const activeAnimation = getActiveAnimation(target);\r\n        switch (key) {\r\n            case \"duration\":\r\n                return target.duration;\r\n            case \"currentTime\":\r\n                return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);\r\n            case \"playbackRate\":\r\n            case \"playState\":\r\n                return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];\r\n            case \"finished\":\r\n                if (!target.finished) {\r\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);\r\n                }\r\n                return target.finished;\r\n            case \"stop\":\r\n                return () => {\r\n                    target.animations.forEach((animation) => stopAnimation(animation));\r\n                };\r\n            case \"forEachNative\":\r\n                /**\r\n                 * This is for internal use only, fire a callback for each\r\n                 * underlying animation.\r\n                 */\r\n                return (callback) => {\r\n                    target.animations.forEach((animation) => callback(animation, target));\r\n                };\r\n            default:\r\n                return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) ===\r\n                    \"undefined\"\r\n                    ? undefined\r\n                    : () => target.animations.forEach((animation) => animation[key]());\r\n        }\r\n    },\r\n    set: (target, key, value) => {\r\n        switch (key) {\r\n            case \"currentTime\":\r\n                value = time.ms(value);\r\n            // Fall-through\r\n            case \"playbackRate\":\r\n                for (let i = 0; i < target.animations.length; i++) {\r\n                    target.animations[i][key] = value;\r\n                }\r\n                return true;\r\n        }\r\n        return false;\r\n    },\r\n};\r\nconst selectFinished = (animation) => animation.finished;\r\n\r\nexport { controls, withControls };\r\n", "import { isNumber, isFunction } from '@motionone/utils';\r\nimport { getEasingFunction } from '@motionone/animation';\r\n\r\nfunction stagger(duration = 0.1, { start = 0, from = 0, easing } = {}) {\r\n    return (i, total) => {\r\n        const fromIndex = isNumber(from) ? from : getFromIndex(from, total);\r\n        const distance = Math.abs(fromIndex - i);\r\n        let delay = duration * distance;\r\n        if (easing) {\r\n            const maxDelay = total * duration;\r\n            const easingFunction = getEasingFunction(easing);\r\n            delay = easingFunction(delay / maxDelay) * maxDelay;\r\n        }\r\n        return start + delay;\r\n    };\r\n}\r\nfunction getFromIndex(from, total) {\r\n    if (from === \"first\") {\r\n        return 0;\r\n    }\r\n    else {\r\n        const lastIndex = total - 1;\r\n        return from === \"last\" ? lastIndex : lastIndex / 2;\r\n    }\r\n}\r\nfunction resolveOption(option, i, total) {\r\n    return isFunction(option) ? option(i, total) : option;\r\n}\r\n\r\nexport { getFromIndex, resolveOption, stagger };\r\n", "import { invariant } from 'hey-listen';\r\nimport { animateStyle } from './animate-style.es.js';\r\nimport { getOptions } from './utils/options.es.js';\r\nimport { resolveElements } from '../utils/resolve-elements.es.js';\r\nimport { withControls } from './utils/controls.es.js';\r\nimport { resolveOption } from '../utils/stagger.es.js';\r\n\r\nfunction createAnimate(AnimatePolyfill) {\r\n    return function animate(elements, keyframes, options = {}) {\r\n        elements = resolveElements(elements);\r\n        const numElements = elements.length;\r\n        invariant(Boolean(numElements), \"No valid element provided.\");\r\n        invariant(Boolean(keyframes), \"No keyframes defined.\");\r\n        /**\r\n         * Create and start new animations\r\n         */\r\n        const animationFactories = [];\r\n        for (let i = 0; i < numElements; i++) {\r\n            const element = elements[i];\r\n            for (const key in keyframes) {\r\n                const valueOptions = getOptions(options, key);\r\n                valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);\r\n                const animation = animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);\r\n                animationFactories.push(animation);\r\n            }\r\n        }\r\n        return withControls(animationFactories, options, \r\n        /**\r\n         * TODO:\r\n         * If easing is set to spring or glide, duration will be dynamically\r\n         * generated. Ideally we would dynamically generate this from\r\n         * animation.effect.getComputedTiming().duration but this isn't\r\n         * supported in iOS13 or our number polyfill. Perhaps it's possible\r\n         * to Proxy animations returned from animateStyle that has duration\r\n         * as a getter.\r\n         */\r\n        options.duration);\r\n    };\r\n}\r\n\r\nexport { createAnimate };\r\n", "import { Animation } from '@motionone/animation';\r\nimport { createAnimate } from './create-animate.es.js';\r\n\r\nconst animate = createAnimate(Animation);\r\n\r\nexport { animate };\r\n", "import { isNumber } from '@motionone/utils';\r\n\r\nfunction calcNextTime(current, next, prev, labels) {\r\n    var _a;\r\n    if (isNumber(next)) {\r\n        return next;\r\n    }\r\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\r\n        return Math.max(0, current + parseFloat(next));\r\n    }\r\n    else if (next === \"<\") {\r\n        return prev;\r\n    }\r\n    else {\r\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\r\n    }\r\n}\r\n\r\nexport { calcNextTime };\r\n", "import { mix, getEasingForSegment, removeItem } from '@motionone/utils';\r\n\r\nfunction eraseKeyframes(sequence, startTime, endTime) {\r\n    for (let i = 0; i < sequence.length; i++) {\r\n        const keyframe = sequence[i];\r\n        if (keyframe.at > startTime && keyframe.at < endTime) {\r\n            removeItem(sequence, keyframe);\r\n            // If we remove this item we have to push the pointer back one\r\n            i--;\r\n        }\r\n    }\r\n}\r\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\r\n    /**\r\n     * Erase every existing value between currentTime and targetTime,\r\n     * this will essentially splice this timeline into any currently\r\n     * defined ones.\r\n     */\r\n    eraseKeyframes(sequence, startTime, endTime);\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        sequence.push({\r\n            value: keyframes[i],\r\n            at: mix(startTime, endTime, offset[i]),\r\n            easing: getEasingForSegment(easing, i),\r\n        });\r\n    }\r\n}\r\n\r\nexport { addKeyframes, eraseKeyframes };\r\n", "function compareByTime(a, b) {\r\n    if (a.at === b.at) {\r\n        return a.value === null ? 1 : -1;\r\n    }\r\n    else {\r\n        return a.at - b.at;\r\n    }\r\n}\r\n\r\nexport { compareByTime };\r\n", "import { __rest } from 'tslib';\r\nimport { invariant } from 'hey-listen';\r\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\r\nimport { resolveOption } from '../utils/stagger.es.js';\r\nimport { animateStyle } from '../animate/animate-style.es.js';\r\nimport { withControls } from '../animate/utils/controls.es.js';\r\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\r\nimport { getOptions } from '../animate/utils/options.es.js';\r\nimport { resolveElements } from '../utils/resolve-elements.es.js';\r\nimport { calcNextTime } from './utils/calc-time.es.js';\r\nimport { addKeyframes } from './utils/edit.es.js';\r\nimport { compareByTime } from './utils/sort.es.js';\r\nimport { Animation } from '@motionone/animation';\r\n\r\nfunction timeline(definition, options = {}) {\r\n    var _a;\r\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\r\n    /**\r\n     * Create and start animations\r\n     */\r\n    const animationFactories = animationDefinitions\r\n        .map((definition) => animateStyle(...definition, Animation))\r\n        .filter(Boolean);\r\n    return withControls(animationFactories, options, \r\n    // Get the duration from the first animation definition\r\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\r\n}\r\nfunction createAnimationsFromTimeline(definition, _a = {}) {\r\n    var { defaultOptions = {} } = _a, timelineOptions = __rest(_a, [\"defaultOptions\"]);\r\n    const animationDefinitions = [];\r\n    const elementSequences = new Map();\r\n    const elementCache = {};\r\n    const timeLabels = new Map();\r\n    let prevTime = 0;\r\n    let currentTime = 0;\r\n    let totalDuration = 0;\r\n    /**\r\n     * Build the timeline by mapping over the definition array and converting\r\n     * the definitions into keyframes and offsets with absolute time values.\r\n     * These will later get converted into relative offsets in a second pass.\r\n     */\r\n    for (let i = 0; i < definition.length; i++) {\r\n        const segment = definition[i];\r\n        /**\r\n         * If this is a timeline label, mark it and skip the rest of this iteration.\r\n         */\r\n        if (isString(segment)) {\r\n            timeLabels.set(segment, currentTime);\r\n            continue;\r\n        }\r\n        else if (!Array.isArray(segment)) {\r\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\r\n            continue;\r\n        }\r\n        const [elementDefinition, keyframes, options = {}] = segment;\r\n        /**\r\n         * If a relative or absolute time value has been specified we need to resolve\r\n         * it in relation to the currentTime.\r\n         */\r\n        if (options.at !== undefined) {\r\n            currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\r\n        }\r\n        /**\r\n         * Keep track of the maximum duration in this definition. This will be\r\n         * applied to currentTime once the definition has been parsed.\r\n         */\r\n        let maxDuration = 0;\r\n        /**\r\n         * Find all the elements specified in the definition and parse value\r\n         * keyframes from their timeline definitions.\r\n         */\r\n        const elements = resolveElements(elementDefinition, elementCache);\r\n        const numElements = elements.length;\r\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\r\n            const element = elements[elementIndex];\r\n            const elementSequence = getElementSequence(element, elementSequences);\r\n            for (const key in keyframes) {\r\n                const valueSequence = getValueSequence(key, elementSequence);\r\n                let valueKeyframes = keyframesList(keyframes[key]);\r\n                const valueOptions = getOptions(options, key);\r\n                let { duration = defaultOptions.duration || defaults.duration, easing = defaultOptions.easing || defaults.easing, } = valueOptions;\r\n                if (isEasingGenerator(easing)) {\r\n                    invariant(key === \"opacity\" || valueKeyframes.length > 1, \"spring must be provided 2 keyframes within timeline()\");\r\n                    const custom = easing.createAnimation(valueKeyframes, key !== \"opacity\", () => 0, key);\r\n                    easing = custom.easing;\r\n                    valueKeyframes = custom.keyframes || valueKeyframes;\r\n                    duration = custom.duration || duration;\r\n                }\r\n                const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\r\n                const startTime = currentTime + delay;\r\n                const targetTime = startTime + duration;\r\n                /**\r\n                 *\r\n                 */\r\n                let { offset = defaultOffset(valueKeyframes.length) } = valueOptions;\r\n                /**\r\n                 * If there's only one offset of 0, fill in a second with length 1\r\n                 *\r\n                 * TODO: Ensure there's a test that covers this removal\r\n                 */\r\n                if (offset.length === 1 && offset[0] === 0) {\r\n                    offset[1] = 1;\r\n                }\r\n                /**\r\n                 * Fill out if offset if fewer offsets than keyframes\r\n                 */\r\n                const remainder = offset.length - valueKeyframes.length;\r\n                remainder > 0 && fillOffset(offset, remainder);\r\n                /**\r\n                 * If only one value has been set, ie [1], push a null to the start of\r\n                 * the keyframe array. This will let us mark a keyframe at this point\r\n                 * that will later be hydrated with the previous value.\r\n                 */\r\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\r\n                /**\r\n                 * Add keyframes, mapping offsets to absolute time.\r\n                 */\r\n                addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\r\n                maxDuration = Math.max(delay + duration, maxDuration);\r\n                totalDuration = Math.max(targetTime, totalDuration);\r\n            }\r\n        }\r\n        prevTime = currentTime;\r\n        currentTime += maxDuration;\r\n    }\r\n    /**\r\n     * For every element and value combination create a new animation.\r\n     */\r\n    elementSequences.forEach((valueSequences, element) => {\r\n        for (const key in valueSequences) {\r\n            const valueSequence = valueSequences[key];\r\n            /**\r\n             * Arrange all the keyframes in ascending time order.\r\n             */\r\n            valueSequence.sort(compareByTime);\r\n            const keyframes = [];\r\n            const valueOffset = [];\r\n            const valueEasing = [];\r\n            /**\r\n             * For each keyframe, translate absolute times into\r\n             * relative offsets based on the total duration of the timeline.\r\n             */\r\n            for (let i = 0; i < valueSequence.length; i++) {\r\n                const { at, value, easing } = valueSequence[i];\r\n                keyframes.push(value);\r\n                valueOffset.push(progress(0, totalDuration, at));\r\n                valueEasing.push(easing || defaults.easing);\r\n            }\r\n            /**\r\n             * If the first keyframe doesn't land on offset: 0\r\n             * provide one by duplicating the initial keyframe. This ensures\r\n             * it snaps to the first keyframe when the animation starts.\r\n             */\r\n            if (valueOffset[0] !== 0) {\r\n                valueOffset.unshift(0);\r\n                keyframes.unshift(keyframes[0]);\r\n                valueEasing.unshift(\"linear\");\r\n            }\r\n            /**\r\n             * If the last keyframe doesn't land on offset: 1\r\n             * provide one with a null wildcard value. This will ensure it\r\n             * stays static until the end of the animation.\r\n             */\r\n            if (valueOffset[valueOffset.length - 1] !== 1) {\r\n                valueOffset.push(1);\r\n                keyframes.push(null);\r\n            }\r\n            animationDefinitions.push([\r\n                element,\r\n                key,\r\n                keyframes,\r\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\r\n            ]);\r\n        }\r\n    });\r\n    return animationDefinitions;\r\n}\r\nfunction getElementSequence(element, sequences) {\r\n    !sequences.has(element) && sequences.set(element, {});\r\n    return sequences.get(element);\r\n}\r\nfunction getValueSequence(name, sequences) {\r\n    if (!sequences[name])\r\n        sequences[name] = [];\r\n    return sequences[name];\r\n}\r\n\r\nexport { createAnimationsFromTimeline, timeline };\r\n", "import { velocityPerSecond } from '@motionone/utils';\r\n\r\nconst sampleT = 5; // ms\r\nfunction calcGeneratorVelocity(resolveValue, t, current) {\r\n    const prevT = Math.max(t - sampleT, 0);\r\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\r\n}\r\n\r\nexport { calcGeneratorVelocity };\r\n", "const defaults = {\r\n    stiffness: 100.0,\r\n    damping: 10.0,\r\n    mass: 1.0,\r\n};\r\n\r\nexport { defaults };\r\n", "import { defaults } from './defaults.es.js';\r\n\r\nconst calcDampingRatio = (stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass) => damping / (2 * Math.sqrt(stiffness * mass));\r\n\r\nexport { calcDampingRatio };\r\n", "function hasReachedTarget(origin, target, current) {\r\n    return ((origin < target && current >= target) ||\r\n        (origin > target && current <= target));\r\n}\r\n\r\nexport { hasReachedTarget };\r\n", "import { time } from '@motionone/utils';\r\nimport { defaults } from './defaults.es.js';\r\nimport { calcDampingRatio } from './utils.es.js';\r\nimport { hasReachedTarget } from '../utils/has-reached-target.es.js';\r\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\r\n\r\nconst spring = ({ stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass, from = 0, to = 1, velocity = 0.0, restSpeed, restDistance, } = {}) => {\r\n    velocity = velocity ? time.s(velocity) : 0.0;\r\n    const state = {\r\n        done: false,\r\n        hasReachedTarget: false,\r\n        current: from,\r\n        target: to,\r\n    };\r\n    const initialDelta = to - from;\r\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\r\n    const dampingRatio = calcDampingRatio(stiffness, damping, mass);\r\n    const isGranularScale = Math.abs(initialDelta) < 5;\r\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\r\n    restDistance || (restDistance = isGranularScale ? 0.005 : 0.5);\r\n    let resolveSpring;\r\n    if (dampingRatio < 1) {\r\n        const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\r\n        // Underdamped spring (bouncy)\r\n        resolveSpring = (t) => to -\r\n            Math.exp(-dampingRatio * undampedAngularFreq * t) *\r\n                (((-velocity + dampingRatio * undampedAngularFreq * initialDelta) /\r\n                    angularFreq) *\r\n                    Math.sin(angularFreq * t) +\r\n                    initialDelta * Math.cos(angularFreq * t));\r\n    }\r\n    else {\r\n        // Critically damped spring\r\n        resolveSpring = (t) => {\r\n            return (to -\r\n                Math.exp(-undampedAngularFreq * t) *\r\n                    (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t));\r\n        };\r\n    }\r\n    return (t) => {\r\n        state.current = resolveSpring(t);\r\n        const currentVelocity = t === 0\r\n            ? velocity\r\n            : calcGeneratorVelocity(resolveSpring, t, state.current);\r\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n        const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;\r\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n        state.hasReachedTarget = hasReachedTarget(from, to, state.current);\r\n        return state;\r\n    };\r\n};\r\n\r\nexport { spring };\r\n", "import { time } from '@motionone/utils';\r\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\r\nimport { spring } from '../spring/index.es.js';\r\n\r\nconst glide = ({ from = 0, velocity = 0.0, power = 0.8, decay = 0.325, bounceDamping, bounceStiffness, changeTarget, min, max, restDistance = 0.5, restSpeed, }) => {\r\n    decay = time.ms(decay);\r\n    const state = {\r\n        hasReachedTarget: false,\r\n        done: false,\r\n        current: from,\r\n        target: from,\r\n    };\r\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\r\n    const nearestBoundary = (v) => {\r\n        if (min === undefined)\r\n            return max;\r\n        if (max === undefined)\r\n            return min;\r\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\r\n    };\r\n    let amplitude = power * velocity;\r\n    const ideal = from + amplitude;\r\n    const target = changeTarget === undefined ? ideal : changeTarget(ideal);\r\n    state.target = target;\r\n    /**\r\n     * If the target has changed we need to re-calculate the amplitude, otherwise\r\n     * the animation will start from the wrong position.\r\n     */\r\n    if (target !== ideal)\r\n        amplitude = target - from;\r\n    const calcDelta = (t) => -amplitude * Math.exp(-t / decay);\r\n    const calcLatest = (t) => target + calcDelta(t);\r\n    const applyFriction = (t) => {\r\n        const delta = calcDelta(t);\r\n        const latest = calcLatest(t);\r\n        state.done = Math.abs(delta) <= restDistance;\r\n        state.current = state.done ? target : latest;\r\n    };\r\n    /**\r\n     * Ideally this would resolve for t in a stateless way, we could\r\n     * do that by always precalculating the animation but as we know\r\n     * this will be done anyway we can assume that spring will\r\n     * be discovered during that.\r\n     */\r\n    let timeReachedBoundary;\r\n    let spring$1;\r\n    const checkCatchBoundary = (t) => {\r\n        if (!isOutOfBounds(state.current))\r\n            return;\r\n        timeReachedBoundary = t;\r\n        spring$1 = spring({\r\n            from: state.current,\r\n            to: nearestBoundary(state.current),\r\n            velocity: calcGeneratorVelocity(calcLatest, t, state.current), // TODO: This should be passing * 1000\r\n            damping: bounceDamping,\r\n            stiffness: bounceStiffness,\r\n            restDistance,\r\n            restSpeed,\r\n        });\r\n    };\r\n    checkCatchBoundary(0);\r\n    return (t) => {\r\n        /**\r\n         * We need to resolve the friction to figure out if we need a\r\n         * spring but we don't want to do this twice per frame. So here\r\n         * we flag if we updated for this frame and later if we did\r\n         * we can skip doing it again.\r\n         */\r\n        let hasUpdatedFrame = false;\r\n        if (!spring$1 && timeReachedBoundary === undefined) {\r\n            hasUpdatedFrame = true;\r\n            applyFriction(t);\r\n            checkCatchBoundary(t);\r\n        }\r\n        /**\r\n         * If we have a spring and the provided t is beyond the moment the friction\r\n         * animation crossed the min/max boundary, use the spring.\r\n         */\r\n        if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\r\n            state.hasReachedTarget = true;\r\n            return spring$1(t - timeReachedBoundary);\r\n        }\r\n        else {\r\n            state.hasReachedTarget = false;\r\n            !hasUpdatedFrame && applyFriction(t);\r\n            return state;\r\n        }\r\n    };\r\n};\r\n\r\nexport { glide };\r\n", "import { noopReturn } from '@motionone/utils';\r\n\r\nconst timeStep = 10;\r\nconst maxDuration = 10000;\r\nfunction pregenerateKeyframes(generator, toUnit = noopReturn) {\r\n    let overshootDuration = undefined;\r\n    let timestamp = timeStep;\r\n    let state = generator(0);\r\n    const keyframes = [toUnit(state.current)];\r\n    while (!state.done && timestamp < maxDuration) {\r\n        state = generator(timestamp);\r\n        keyframes.push(toUnit(state.done ? state.target : state.current));\r\n        if (overshootDuration === undefined && state.hasReachedTarget) {\r\n            overshootDuration = timestamp;\r\n        }\r\n        timestamp += timeStep;\r\n    }\r\n    const duration = timestamp - timeStep;\r\n    /**\r\n     * If generating an animation that didn't actually move,\r\n     * generate a second keyframe so we have an origin and target.\r\n     */\r\n    if (keyframes.length === 1)\r\n        keyframes.push(state.current);\r\n    return {\r\n        keyframes,\r\n        duration: duration / 1000,\r\n        overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1000,\r\n    };\r\n}\r\n\r\nexport { pregenerateKeyframes };\r\n", "import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\r\nimport { isNumber, isString, noopReturn } from '@motionone/utils';\r\nimport { getUnitConverter } from '../animate/utils/get-unit.es.js';\r\nimport { transformDefinitions } from '../animate/utils/transforms.es.js';\r\nimport { getStyleName } from '../animate/utils/get-style-name.es.js';\r\n\r\nfunction canGenerate(value) {\r\n    return isNumber(value) && !isNaN(value);\r\n}\r\nfunction getAsNumber(value) {\r\n    return isString(value) ? parseFloat(value) : value;\r\n}\r\nfunction createGeneratorEasing(createGenerator) {\r\n    const keyframesCache = new WeakMap();\r\n    return (options = {}) => {\r\n        const generatorCache = new Map();\r\n        const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\r\n            const key = `${from}-${to}-${velocity}-${isScale}`;\r\n            if (!generatorCache.has(key)) {\r\n                generatorCache.set(key, createGenerator(Object.assign({ from,\r\n                    to,\r\n                    velocity }, options)));\r\n            }\r\n            return generatorCache.get(key);\r\n        };\r\n        const getKeyframes = (generator, toUnit) => {\r\n            if (!keyframesCache.has(generator)) {\r\n                keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));\r\n            }\r\n            return keyframesCache.get(generator);\r\n        };\r\n        return {\r\n            createAnimation: (keyframes, shouldGenerate = true, getOrigin, name, motionValue) => {\r\n                let settings;\r\n                let origin;\r\n                let target;\r\n                let velocity = 0;\r\n                let toUnit = noopReturn;\r\n                const numKeyframes = keyframes.length;\r\n                /**\r\n                 * If we should generate an animation for this value, run some preperation\r\n                 * like resolving target/origin, finding a unit (if any) and determine if\r\n                 * it is actually possible to generate.\r\n                 */\r\n                if (shouldGenerate) {\r\n                    toUnit = getUnitConverter(keyframes, name ? transformDefinitions.get(getStyleName(name)) : undefined);\r\n                    const targetDefinition = keyframes[numKeyframes - 1];\r\n                    target = getAsNumber(targetDefinition);\r\n                    if (numKeyframes > 1 && keyframes[0] !== null) {\r\n                        /**\r\n                         * If we have multiple keyframes, take the initial keyframe as the origin.\r\n                         */\r\n                        origin = getAsNumber(keyframes[0]);\r\n                    }\r\n                    else {\r\n                        const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\r\n                        /**\r\n                         * If we have an existing generator for this value we can use it to resolve\r\n                         * the animation's current value and velocity.\r\n                         */\r\n                        if (prevGenerator) {\r\n                            /**\r\n                             * If we have a generator for this value we can use it to resolve\r\n                             * the animations's current value and velocity.\r\n                             */\r\n                            const { animation, generatorStartTime } = motionValue;\r\n                            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\r\n                            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\r\n                            const prevGeneratorCurrent = prevGenerator(currentTime).current;\r\n                            origin = prevGeneratorCurrent;\r\n                            velocity = calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\r\n                        }\r\n                        else if (getOrigin) {\r\n                            /**\r\n                             * As a last resort, read the origin from the DOM.\r\n                             */\r\n                            origin = getAsNumber(getOrigin());\r\n                        }\r\n                    }\r\n                }\r\n                /**\r\n                 * If we've determined it is possible to generate an animation, do so.\r\n                 */\r\n                if (canGenerate(origin) && canGenerate(target)) {\r\n                    const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\r\n                    settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), { easing: \"linear\" });\r\n                    // TODO Add test for this\r\n                    if (motionValue) {\r\n                        motionValue.generator = generator;\r\n                        motionValue.generatorStartTime = performance.now();\r\n                    }\r\n                }\r\n                /**\r\n                 * If by now we haven't generated a set of keyframes, create a generic generator\r\n                 * based on the provided props that animates from 0-100 to fetch a rough\r\n                 * \"overshootDuration\" - the moment when the generator first hits the animation target.\r\n                 * Then return animation settings that will run a normal animation for that duration.\r\n                 */\r\n                if (!settings) {\r\n                    const keyframesMetadata = getKeyframes(getGenerator(0, 100));\r\n                    settings = {\r\n                        easing: \"ease\",\r\n                        duration: keyframesMetadata.overshootDuration,\r\n                    };\r\n                }\r\n                return settings;\r\n            },\r\n        };\r\n    };\r\n}\r\n\r\nexport { createGeneratorEasing };\r\n", "import { spring as spring$1 } from '@motionone/generators';\r\nimport { createGeneratorEasing } from '../create-generator-easing.es.js';\r\n\r\nconst spring = createGeneratorEasing(spring$1);\r\n\r\nexport { spring };\r\n", "import { glide as glide$1 } from '@motionone/generators';\r\nimport { createGeneratorEasing } from '../create-generator-easing.es.js';\r\n\r\nconst glide = createGeneratorEasing(glide$1);\r\n\r\nexport { glide };\r\n", "import { resolveElements } from '../utils/resolve-elements.es.js';\r\nimport { isFunction } from '@motionone/utils';\r\n\r\nconst thresholds = {\r\n    any: 0,\r\n    all: 1,\r\n};\r\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"any\" } = {}) {\r\n    /**\r\n     * If this browser doesn't support IntersectionObserver, return a dummy stop function.\r\n     * Default triggering of onStart is tricky - it could be used for starting/stopping\r\n     * videos, lazy loading content etc. We could provide an option to enable a fallback, or\r\n     * provide a fallback callback option.\r\n     */\r\n    if (typeof IntersectionObserver === \"undefined\") {\r\n        return () => { };\r\n    }\r\n    const elements = resolveElements(elementOrSelector);\r\n    const activeIntersections = new WeakMap();\r\n    const onIntersectionChange = (entries) => {\r\n        entries.forEach((entry) => {\r\n            const onEnd = activeIntersections.get(entry.target);\r\n            /**\r\n             * If there's no change to the intersection, we don't need to\r\n             * do anything here.\r\n             */\r\n            if (entry.isIntersecting === Boolean(onEnd))\r\n                return;\r\n            if (entry.isIntersecting) {\r\n                const newOnEnd = onStart(entry);\r\n                if (isFunction(newOnEnd)) {\r\n                    activeIntersections.set(entry.target, newOnEnd);\r\n                }\r\n                else {\r\n                    observer.unobserve(entry.target);\r\n                }\r\n            }\r\n            else if (onEnd) {\r\n                onEnd(entry);\r\n                activeIntersections.delete(entry.target);\r\n            }\r\n        });\r\n    };\r\n    const observer = new IntersectionObserver(onIntersectionChange, {\r\n        root,\r\n        rootMargin,\r\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\r\n    });\r\n    elements.forEach((element) => observer.observe(element));\r\n    return () => observer.disconnect();\r\n}\r\n\r\nexport { inView };\r\n", "import { resolveElements } from '../../utils/resolve-elements.es.js';\r\n\r\nconst resizeHandlers = new WeakMap();\r\nlet observer;\r\nfunction getElementSize(target, borderBoxSize) {\r\n    if (borderBoxSize) {\r\n        const { inlineSize, blockSize } = borderBoxSize[0];\r\n        return { width: inlineSize, height: blockSize };\r\n    }\r\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\r\n        return target.getBBox();\r\n    }\r\n    else {\r\n        return {\r\n            width: target.offsetWidth,\r\n            height: target.offsetHeight,\r\n        };\r\n    }\r\n}\r\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\r\n    var _a;\r\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\r\n        handler({\r\n            target,\r\n            contentSize: contentRect,\r\n            get size() {\r\n                return getElementSize(target, borderBoxSize);\r\n            },\r\n        });\r\n    });\r\n}\r\nfunction notifyAll(entries) {\r\n    entries.forEach(notifyTarget);\r\n}\r\nfunction createResizeObserver() {\r\n    if (typeof ResizeObserver === \"undefined\")\r\n        return;\r\n    observer = new ResizeObserver(notifyAll);\r\n}\r\nfunction resizeElement(target, handler) {\r\n    if (!observer)\r\n        createResizeObserver();\r\n    const elements = resolveElements(target);\r\n    elements.forEach((element) => {\r\n        let elementHandlers = resizeHandlers.get(element);\r\n        if (!elementHandlers) {\r\n            elementHandlers = new Set();\r\n            resizeHandlers.set(element, elementHandlers);\r\n        }\r\n        elementHandlers.add(handler);\r\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\r\n    });\r\n    return () => {\r\n        elements.forEach((element) => {\r\n            const elementHandlers = resizeHandlers.get(element);\r\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\r\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\r\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\r\n            }\r\n        });\r\n    };\r\n}\r\n\r\nexport { resizeElement };\r\n", "const windowCallbacks = new Set();\r\nlet windowResizeHandler;\r\nfunction createWindowResizeHandler() {\r\n    windowResizeHandler = () => {\r\n        const size = {\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        };\r\n        const info = {\r\n            target: window,\r\n            size,\r\n            contentSize: size,\r\n        };\r\n        windowCallbacks.forEach((callback) => callback(info));\r\n    };\r\n    window.addEventListener(\"resize\", windowResizeHandler);\r\n}\r\nfunction resizeWindow(callback) {\r\n    windowCallbacks.add(callback);\r\n    if (!windowResizeHandler)\r\n        createWindowResizeHandler();\r\n    return () => {\r\n        windowCallbacks.delete(callback);\r\n        if (!windowCallbacks.size && windowResizeHandler) {\r\n            windowResizeHandler = undefined;\r\n        }\r\n    };\r\n}\r\n\r\nexport { resizeWindow };\r\n", "import { resizeElement } from './handle-element.es.js';\r\nimport { resizeWindow } from './handle-window.es.js';\r\nimport { isFunction } from '@motionone/utils';\r\n\r\nfunction resize(a, b) {\r\n    return isFunction(a) ? resizeWindow(a) : resizeElement(a, b);\r\n}\r\n\r\nexport { resize };\r\n", "import { progress, velocityPerSecond } from '@motionone/utils';\r\n\r\n/**\r\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\r\n */\r\nconst maxElapsed = 50;\r\nconst createAxisInfo = () => ({\r\n    current: 0,\r\n    offset: [],\r\n    progress: 0,\r\n    scrollLength: 0,\r\n    targetOffset: 0,\r\n    targetLength: 0,\r\n    containerLength: 0,\r\n    velocity: 0,\r\n});\r\nconst createScrollInfo = () => ({\r\n    time: 0,\r\n    x: createAxisInfo(),\r\n    y: createAxisInfo(),\r\n});\r\nconst keys = {\r\n    x: {\r\n        length: \"Width\",\r\n        position: \"Left\",\r\n    },\r\n    y: {\r\n        length: \"Height\",\r\n        position: \"Top\",\r\n    },\r\n};\r\nfunction updateAxisInfo(element, axisName, info, time) {\r\n    const axis = info[axisName];\r\n    const { length, position } = keys[axisName];\r\n    const prev = axis.current;\r\n    const prevTime = info.time;\r\n    axis.current = element[`scroll${position}`];\r\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\r\n    axis.offset.length = 0;\r\n    axis.offset[0] = 0;\r\n    axis.offset[1] = axis.scrollLength;\r\n    axis.progress = progress(0, axis.scrollLength, axis.current);\r\n    const elapsed = time - prevTime;\r\n    axis.velocity =\r\n        elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);\r\n}\r\nfunction updateScrollInfo(element, info, time) {\r\n    updateAxisInfo(element, \"x\", info, time);\r\n    updateAxisInfo(element, \"y\", info, time);\r\n    info.time = time;\r\n}\r\n\r\nexport { createScrollInfo, updateScrollInfo };\r\n", "function calcInset(element, container) {\r\n    let inset = { x: 0, y: 0 };\r\n    let current = element;\r\n    while (current && current !== container) {\r\n        if (current instanceof HTMLElement) {\r\n            inset.x += current.offsetLeft;\r\n            inset.y += current.offsetTop;\r\n            current = current.offsetParent;\r\n        }\r\n        else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\r\n            const { top, left } = current.getBBox();\r\n            inset.x += left;\r\n            inset.y += top;\r\n            /**\r\n             * Assign the next parent element as the <svg /> tag.\r\n             */\r\n            while (current && current.tagName !== \"svg\") {\r\n                current = current.parentNode;\r\n            }\r\n        }\r\n    }\r\n    return inset;\r\n}\r\n\r\nexport { calcInset };\r\n", "const ScrollOffset = {\r\n    Enter: [\r\n        [0, 1],\r\n        [1, 1],\r\n    ],\r\n    Exit: [\r\n        [0, 0],\r\n        [1, 0],\r\n    ],\r\n    Any: [\r\n        [1, 0],\r\n        [0, 1],\r\n    ],\r\n    All: [\r\n        [0, 0],\r\n        [1, 1],\r\n    ],\r\n};\r\n\r\nexport { ScrollOffset };\r\n", "import { isString, isNumber } from '@motionone/utils';\r\n\r\nconst namedEdges = {\r\n    start: 0,\r\n    center: 0.5,\r\n    end: 1,\r\n};\r\nfunction resolveEdge(edge, length, inset = 0) {\r\n    let delta = 0;\r\n    /**\r\n     * If we have this edge defined as a preset, replace the definition\r\n     * with the numerical value.\r\n     */\r\n    if (namedEdges[edge] !== undefined) {\r\n        edge = namedEdges[edge];\r\n    }\r\n    /**\r\n     * Handle unit values\r\n     */\r\n    if (isString(edge)) {\r\n        const asNumber = parseFloat(edge);\r\n        if (edge.endsWith(\"px\")) {\r\n            delta = asNumber;\r\n        }\r\n        else if (edge.endsWith(\"%\")) {\r\n            edge = asNumber / 100;\r\n        }\r\n        else if (edge.endsWith(\"vw\")) {\r\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\r\n        }\r\n        else if (edge.endsWith(\"vh\")) {\r\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\r\n        }\r\n        else {\r\n            edge = asNumber;\r\n        }\r\n    }\r\n    /**\r\n     * If the edge is defined as a number, handle as a progress value.\r\n     */\r\n    if (isNumber(edge)) {\r\n        delta = length * edge;\r\n    }\r\n    return inset + delta;\r\n}\r\n\r\nexport { namedEdges, resolveEdge };\r\n", "import { isNumber, isString } from '@motionone/utils';\r\nimport { resolveEdge, namedEdges } from './edge.es.js';\r\n\r\nconst defaultOffset = [0, 0];\r\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\r\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\r\n    let targetPoint = 0;\r\n    let containerPoint = 0;\r\n    if (isNumber(offset)) {\r\n        /**\r\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\r\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\r\n         * and container etc.\r\n         */\r\n        offsetDefinition = [offset, offset];\r\n    }\r\n    else if (isString(offset)) {\r\n        offset = offset.trim();\r\n        if (offset.includes(\" \")) {\r\n            offsetDefinition = offset.split(\" \");\r\n        }\r\n        else {\r\n            /**\r\n             * If we're provided a definition like \"100px\" then we want to apply\r\n             * that only to the top of the target point, leaving the container at 0.\r\n             * Whereas a named offset like \"end\" should be applied to both.\r\n             */\r\n            offsetDefinition = [\r\n                offset,\r\n                namedEdges[offset] ? offset : `0`,\r\n            ];\r\n        }\r\n    }\r\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\r\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\r\n    return targetPoint - containerPoint;\r\n}\r\n\r\nexport { resolveOffset };\r\n", "import { interpolate, defaultOffset } from '@motionone/utils';\r\nimport { calcInset } from './inset.es.js';\r\nimport { ScrollOffset } from './presets.es.js';\r\nimport { resolveOffset } from './offset.es.js';\r\n\r\nconst point = { x: 0, y: 0 };\r\nfunction resolveOffsets(container, info, options) {\r\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\r\n    const { target = container, axis = \"y\" } = options;\r\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\r\n    const inset = target !== container ? calcInset(target, container) : point;\r\n    /**\r\n     * Measure the target and container. If they're the same thing then we\r\n     * use the container's scrollWidth/Height as the target, from there\r\n     * all other calculations can remain the same.\r\n     */\r\n    const targetSize = target === container\r\n        ? { width: container.scrollWidth, height: container.scrollHeight }\r\n        : { width: target.clientWidth, height: target.clientHeight };\r\n    const containerSize = {\r\n        width: container.clientWidth,\r\n        height: container.clientHeight,\r\n    };\r\n    /**\r\n     * Reset the length of the resolved offset array rather than creating a new one.\r\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\r\n     */\r\n    info[axis].offset.length = 0;\r\n    /**\r\n     * Populate the offset array by resolving the user's offset definition into\r\n     * a list of pixel scroll offets.\r\n     */\r\n    let hasChanged = !info[axis].interpolate;\r\n    const numOffsets = offsetDefinition.length;\r\n    for (let i = 0; i < numOffsets; i++) {\r\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\r\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\r\n            hasChanged = true;\r\n        }\r\n        info[axis].offset[i] = offset;\r\n    }\r\n    /**\r\n     * If the pixel scroll offsets have changed, create a new interpolator function\r\n     * to map scroll value into a progress.\r\n     */\r\n    if (hasChanged) {\r\n        info[axis].interpolate = interpolate(defaultOffset(numOffsets), info[axis].offset);\r\n        info[axis].interpolatorOffsets = [...info[axis].offset];\r\n    }\r\n    info[axis].progress = info[axis].interpolate(info[axis].current);\r\n}\r\n\r\nexport { resolveOffsets };\r\n", "import { isFunction, noopReturn } from '@motionone/utils';\r\nimport { updateScrollInfo } from './info.es.js';\r\nimport { resolveOffsets } from './offsets/index.es.js';\r\n\r\nfunction measure(container, target = container, info) {\r\n    /**\r\n     * Find inset of target within scrollable container\r\n     */\r\n    info.x.targetOffset = 0;\r\n    info.y.targetOffset = 0;\r\n    if (target !== container) {\r\n        let node = target;\r\n        while (node && node != container) {\r\n            info.x.targetOffset += node.offsetLeft;\r\n            info.y.targetOffset += node.offsetTop;\r\n            node = node.offsetParent;\r\n        }\r\n    }\r\n    info.x.targetLength =\r\n        target === container ? target.scrollWidth : target.clientWidth;\r\n    info.y.targetLength =\r\n        target === container ? target.scrollHeight : target.clientHeight;\r\n    info.x.containerLength = container.clientWidth;\r\n    info.y.containerLength = container.clientHeight;\r\n}\r\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\r\n    const axis = options.axis || \"y\";\r\n    return {\r\n        measure: () => measure(element, options.target, info),\r\n        update: (time) => {\r\n            updateScrollInfo(element, info, time);\r\n            if (options.offset || options.target) {\r\n                resolveOffsets(element, info, options);\r\n            }\r\n        },\r\n        notify: isFunction(onScroll)\r\n            ? () => onScroll(info)\r\n            : scrubAnimation(onScroll, info[axis]),\r\n    };\r\n}\r\nfunction scrubAnimation(controls, axisInfo) {\r\n    controls.pause();\r\n    controls.forEachNative((animation, { easing }) => {\r\n        var _a, _b;\r\n        if (animation.updateDuration) {\r\n            if (!easing)\r\n                animation.easing = noopReturn;\r\n            animation.updateDuration(1);\r\n        }\r\n        else {\r\n            const timingOptions = { duration: 1000 };\r\n            if (!easing)\r\n                timingOptions.easing = \"linear\";\r\n            (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\r\n        }\r\n    });\r\n    return () => {\r\n        controls.currentTime = axisInfo.progress;\r\n    };\r\n}\r\n\r\nexport { createOnScrollHandler };\r\n", "import { __rest } from 'tslib';\r\nimport { resize } from '../resize/index.es.js';\r\nimport { createScrollInfo } from './info.es.js';\r\nimport { createOnScrollHandler } from './on-scroll-handler.es.js';\r\n\r\nconst scrollListeners = new WeakMap();\r\nconst resizeListeners = new WeakMap();\r\nconst onScrollHandlers = new WeakMap();\r\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\r\nfunction scroll(onScroll, _a = {}) {\r\n    var { container = document.documentElement } = _a, options = __rest(_a, [\"container\"]);\r\n    let containerHandlers = onScrollHandlers.get(container);\r\n    /**\r\n     * Get the onScroll handlers for this container.\r\n     * If one isn't found, create a new one.\r\n     */\r\n    if (!containerHandlers) {\r\n        containerHandlers = new Set();\r\n        onScrollHandlers.set(container, containerHandlers);\r\n    }\r\n    /**\r\n     * Create a new onScroll handler for the provided callback.\r\n     */\r\n    const info = createScrollInfo();\r\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\r\n    containerHandlers.add(containerHandler);\r\n    /**\r\n     * Check if there's a scroll event listener for this container.\r\n     * If not, create one.\r\n     */\r\n    if (!scrollListeners.has(container)) {\r\n        const listener = () => {\r\n            const time = performance.now();\r\n            for (const handler of containerHandlers)\r\n                handler.measure();\r\n            for (const handler of containerHandlers)\r\n                handler.update(time);\r\n            for (const handler of containerHandlers)\r\n                handler.notify();\r\n        };\r\n        scrollListeners.set(container, listener);\r\n        const target = getEventTarget(container);\r\n        window.addEventListener(\"resize\", listener, { passive: true });\r\n        if (container !== document.documentElement) {\r\n            resizeListeners.set(container, resize(container, listener));\r\n        }\r\n        target.addEventListener(\"scroll\", listener, { passive: true });\r\n    }\r\n    const listener = scrollListeners.get(container);\r\n    const onLoadProcesss = requestAnimationFrame(listener);\r\n    return () => {\r\n        var _a;\r\n        if (typeof onScroll !== \"function\")\r\n            onScroll.stop();\r\n        cancelAnimationFrame(onLoadProcesss);\r\n        /**\r\n         * Check if we even have any handlers for this container.\r\n         */\r\n        const containerHandlers = onScrollHandlers.get(container);\r\n        if (!containerHandlers)\r\n            return;\r\n        containerHandlers.delete(containerHandler);\r\n        if (containerHandlers.size)\r\n            return;\r\n        /**\r\n         * If no more handlers, remove the scroll listener too.\r\n         */\r\n        const listener = scrollListeners.get(container);\r\n        scrollListeners.delete(container);\r\n        if (listener) {\r\n            getEventTarget(container).removeEventListener(\"scroll\", listener);\r\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\r\n            window.removeEventListener(\"resize\", listener);\r\n        }\r\n    };\r\n}\r\n\r\nexport { scroll };\r\n", "function hasChanged(a, b) {\r\n    if (typeof a !== typeof b)\r\n        return true;\r\n    if (Array.isArray(a) && Array.isArray(b))\r\n        return !shallowCompare(a, b);\r\n    return a !== b;\r\n}\r\nfunction shallowCompare(next, prev) {\r\n    const prevLength = prev.length;\r\n    if (prevLength !== next.length)\r\n        return false;\r\n    for (let i = 0; i < prevLength; i++) {\r\n        if (prev[i] !== next[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport { hasChanged, shallowCompare };\r\n", "function isVariant(definition) {\r\n    return typeof definition === \"object\";\r\n}\r\n\r\nexport { isVariant };\r\n", "import { isVariant } from './is-variant.es.js';\r\n\r\nfunction resolveVariant(definition, variants) {\r\n    if (isVariant(definition)) {\r\n        return definition;\r\n    }\r\n    else if (definition && variants) {\r\n        return variants[definition];\r\n    }\r\n}\r\n\r\nexport { resolveVariant };\r\n", "import { addUniqueItem, removeItem } from '@motionone/utils';\r\n\r\nlet scheduled = undefined;\r\nfunction processScheduledAnimations() {\r\n    if (!scheduled)\r\n        return;\r\n    const generators = scheduled.sort(compareByDepth).map(fireAnimateUpdates);\r\n    generators.forEach(fireNext);\r\n    generators.forEach(fireNext);\r\n    scheduled = undefined;\r\n}\r\nfunction scheduleAnimation(state) {\r\n    if (!scheduled) {\r\n        scheduled = [state];\r\n        requestAnimationFrame(processScheduledAnimations);\r\n    }\r\n    else {\r\n        addUniqueItem(scheduled, state);\r\n    }\r\n}\r\nfunction unscheduleAnimation(state) {\r\n    scheduled && removeItem(scheduled, state);\r\n}\r\nconst compareByDepth = (a, b) => a.getDepth() - b.getDepth();\r\nconst fireAnimateUpdates = (state) => state.animateUpdates();\r\nconst fireNext = (iterator) => iterator.next();\r\n\r\nexport { scheduleAnimation, unscheduleAnimation };\r\n", "const motionEvent = (name, target) => new CustomEvent(name, { detail: { target } });\r\nfunction dispatchPointerEvent(element, name, event) {\r\n    element.dispatchEvent(new CustomEvent(name, { detail: { originalEvent: event } }));\r\n}\r\nfunction dispatchViewEvent(element, name, entry) {\r\n    element.dispatchEvent(new CustomEvent(name, { detail: { originalEntry: entry } }));\r\n}\r\n\r\nexport { dispatchPointerEvent, dispatchViewEvent, motionEvent };\r\n", "import { __rest } from 'tslib';\r\nimport { dispatchViewEvent } from '../utils/events.es.js';\r\nimport { inView as inView$1 } from '../../gestures/in-view.es.js';\r\n\r\nconst inView = {\r\n    isActive: (options) => Boolean(options.inView),\r\n    subscribe: (element, { enable, disable }, { inViewOptions = {} }) => {\r\n        const { once } = inViewOptions, viewOptions = __rest(inViewOptions, [\"once\"]);\r\n        return inView$1(element, (enterEntry) => {\r\n            enable();\r\n            dispatchViewEvent(element, \"viewenter\", enterEntry);\r\n            if (!once) {\r\n                return (leaveEntry) => {\r\n                    disable();\r\n                    dispatchViewEvent(element, \"viewleave\", leaveEntry);\r\n                };\r\n            }\r\n        }, viewOptions);\r\n    },\r\n};\r\n\r\nexport { inView };\r\n", "import { dispatchPointerEvent } from '../utils/events.es.js';\r\n\r\nconst mouseEvent = (element, name, action) => (event) => {\r\n    if (event.pointerType && event.pointerType !== \"mouse\")\r\n        return;\r\n    action();\r\n    dispatchPointerEvent(element, name, event);\r\n};\r\nconst hover = {\r\n    isActive: (options) => Boolean(options.hover),\r\n    subscribe: (element, { enable, disable }) => {\r\n        const onEnter = mouseEvent(element, \"hoverstart\", enable);\r\n        const onLeave = mouseEvent(element, \"hoverend\", disable);\r\n        element.addEventListener(\"pointerenter\", onEnter);\r\n        element.addEventListener(\"pointerleave\", onLeave);\r\n        return () => {\r\n            element.removeEventListener(\"pointerenter\", onEnter);\r\n            element.removeEventListener(\"pointerleave\", onLeave);\r\n        };\r\n    },\r\n};\r\n\r\nexport { hover };\r\n", "import { dispatchPointerEvent } from '../utils/events.es.js';\r\n\r\nconst press = {\r\n    isActive: (options) => Boolean(options.press),\r\n    subscribe: (element, { enable, disable }) => {\r\n        const onPointerUp = (event) => {\r\n            disable();\r\n            dispatchPointerEvent(element, \"pressend\", event);\r\n            window.removeEventListener(\"pointerup\", onPointerUp);\r\n        };\r\n        const onPointerDown = (event) => {\r\n            enable();\r\n            dispatchPointerEvent(element, \"pressstart\", event);\r\n            window.addEventListener(\"pointerup\", onPointerUp);\r\n        };\r\n        element.addEventListener(\"pointerdown\", onPointerDown);\r\n        return () => {\r\n            element.removeEventListener(\"pointerdown\", onPointerDown);\r\n            window.removeEventListener(\"pointerup\", onPointerUp);\r\n        };\r\n    },\r\n};\r\n\r\nexport { press };\r\n", "import { __rest } from 'tslib';\r\nimport { invariant } from 'hey-listen';\r\nimport { noop } from '@motionone/utils';\r\nimport { animateStyle } from '../animate/animate-style.es.js';\r\nimport { style } from '../animate/style.es.js';\r\nimport { getOptions } from '../animate/utils/options.es.js';\r\nimport { hasChanged } from './utils/has-changed.es.js';\r\nimport { resolveVariant } from './utils/resolve-variant.es.js';\r\nimport { scheduleAnimation, unscheduleAnimation } from './utils/schedule.es.js';\r\nimport { inView } from './gestures/in-view.es.js';\r\nimport { hover } from './gestures/hover.es.js';\r\nimport { press } from './gestures/press.es.js';\r\nimport { motionEvent } from './utils/events.es.js';\r\nimport { Animation } from '@motionone/animation';\r\n\r\nconst gestures = { inView, hover, press };\r\n/**\r\n * A list of state types, in priority order. If a value is defined in\r\n * a righter-most type, it will override any definition in a lefter-most.\r\n */\r\nconst stateTypes = [\"initial\", \"animate\", ...Object.keys(gestures), \"exit\"];\r\n/**\r\n * A global store of all generated motion states. This can be used to lookup\r\n * a motion state for a given Element.\r\n */\r\nconst mountedStates = new WeakMap();\r\nfunction createMotionState(options = {}, parent) {\r\n    /**\r\n     * The element represented by the motion state. This is an empty reference\r\n     * when we create the state to support SSR and allow for later mounting\r\n     * in view libraries.\r\n     *\r\n     * @ts-ignore\r\n     */\r\n    let element;\r\n    /**\r\n     * Calculate a depth that we can use to order motion states by tree depth.\r\n     */\r\n    let depth = parent ? parent.getDepth() + 1 : 0;\r\n    /**\r\n     * Track which states are currently active.\r\n     */\r\n    const activeStates = { initial: true, animate: true };\r\n    /**\r\n     * A map of functions that, when called, will remove event listeners for\r\n     * a given gesture.\r\n     */\r\n    const gestureSubscriptions = {};\r\n    /**\r\n     * Initialise a context to share through motion states. This\r\n     * will be populated by variant names (if any).\r\n     */\r\n    const context = {};\r\n    for (const name of stateTypes) {\r\n        context[name] =\r\n            typeof options[name] === \"string\"\r\n                ? options[name]\r\n                : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];\r\n    }\r\n    /**\r\n     * If initial is set to false we use the animate prop as the initial\r\n     * animation state.\r\n     */\r\n    const initialVariantSource = options.initial === false ? \"animate\" : \"initial\";\r\n    /**\r\n     * Destructure an initial target out from the resolved initial variant.\r\n     */\r\n    let _a = resolveVariant(options[initialVariantSource] || context[initialVariantSource], options.variants) || {}, target = __rest(_a, [\"transition\"]);\r\n    /**\r\n     * The base target is a cached map of values that we'll use to animate\r\n     * back to if a value is removed from all active state types. This\r\n     * is usually the initial value as read from the DOM, for instance if\r\n     * it hasn't been defined in initial.\r\n     */\r\n    const baseTarget = Object.assign({}, target);\r\n    /**\r\n     * A generator that will be processed by the global animation scheduler.\r\n     * This yields when it switches from reading the DOM to writing to it\r\n     * to prevent layout thrashing.\r\n     */\r\n    function* animateUpdates() {\r\n        var _a, _b;\r\n        const prevTarget = target;\r\n        target = {};\r\n        const animationOptions = {};\r\n        for (const name of stateTypes) {\r\n            if (!activeStates[name])\r\n                continue;\r\n            const variant = resolveVariant(options[name]);\r\n            if (!variant)\r\n                continue;\r\n            for (const key in variant) {\r\n                if (key === \"transition\")\r\n                    continue;\r\n                target[key] = variant[key];\r\n                animationOptions[key] = getOptions((_b = (_a = variant.transition) !== null && _a !== void 0 ? _a : options.transition) !== null && _b !== void 0 ? _b : {}, key);\r\n            }\r\n        }\r\n        const allTargetKeys = new Set([\r\n            ...Object.keys(target),\r\n            ...Object.keys(prevTarget),\r\n        ]);\r\n        const animationFactories = [];\r\n        allTargetKeys.forEach((key) => {\r\n            var _a;\r\n            if (target[key] === undefined) {\r\n                target[key] = baseTarget[key];\r\n            }\r\n            if (hasChanged(prevTarget[key], target[key])) {\r\n                (_a = baseTarget[key]) !== null && _a !== void 0 ? _a : (baseTarget[key] = style.get(element, key));\r\n                animationFactories.push(animateStyle(element, key, target[key], animationOptions[key], Animation));\r\n            }\r\n        });\r\n        // Wait for all animation states to read from the DOM\r\n        yield;\r\n        const animations = animationFactories\r\n            .map((factory) => factory())\r\n            .filter(Boolean);\r\n        if (!animations.length)\r\n            return;\r\n        const animationTarget = target;\r\n        element.dispatchEvent(motionEvent(\"motionstart\", animationTarget));\r\n        Promise.all(animations.map((animation) => animation.finished))\r\n            .then(() => {\r\n            element.dispatchEvent(motionEvent(\"motioncomplete\", animationTarget));\r\n        })\r\n            .catch(noop);\r\n    }\r\n    const setGesture = (name, isActive) => () => {\r\n        activeStates[name] = isActive;\r\n        scheduleAnimation(state);\r\n    };\r\n    const updateGestureSubscriptions = () => {\r\n        for (const name in gestures) {\r\n            const isGestureActive = gestures[name].isActive(options);\r\n            const remove = gestureSubscriptions[name];\r\n            if (isGestureActive && !remove) {\r\n                gestureSubscriptions[name] = gestures[name].subscribe(element, {\r\n                    enable: setGesture(name, true),\r\n                    disable: setGesture(name, false),\r\n                }, options);\r\n            }\r\n            else if (!isGestureActive && remove) {\r\n                remove();\r\n                delete gestureSubscriptions[name];\r\n            }\r\n        }\r\n    };\r\n    const state = {\r\n        update: (newOptions) => {\r\n            if (!element)\r\n                return;\r\n            options = newOptions;\r\n            updateGestureSubscriptions();\r\n            scheduleAnimation(state);\r\n        },\r\n        setActive: (name, isActive) => {\r\n            if (!element)\r\n                return;\r\n            activeStates[name] = isActive;\r\n            scheduleAnimation(state);\r\n        },\r\n        animateUpdates,\r\n        getDepth: () => depth,\r\n        getTarget: () => target,\r\n        getOptions: () => options,\r\n        getContext: () => context,\r\n        mount: (newElement) => {\r\n            invariant(Boolean(newElement), \"Animation state must be mounted with valid Element\");\r\n            element = newElement;\r\n            mountedStates.set(element, state);\r\n            updateGestureSubscriptions();\r\n            return () => {\r\n                mountedStates.delete(element);\r\n                unscheduleAnimation(state);\r\n                for (const key in gestureSubscriptions) {\r\n                    gestureSubscriptions[key]();\r\n                }\r\n            };\r\n        },\r\n        isMounted: () => Boolean(element),\r\n    };\r\n    return state;\r\n}\r\n\r\nexport { createMotionState, mountedStates };\r\n", "import { isNumber } from '@motionone/utils';\r\nimport { isTransform, transformAlias, asTransformCssVar, transformDefinitions, buildTransformTemplate } from './transforms.es.js';\r\n\r\nfunction createStyles(keyframes) {\r\n    const initialKeyframes = {};\r\n    const transformKeys = [];\r\n    for (let key in keyframes) {\r\n        const value = keyframes[key];\r\n        if (isTransform(key)) {\r\n            if (transformAlias[key])\r\n                key = transformAlias[key];\r\n            transformKeys.push(key);\r\n            key = asTransformCssVar(key);\r\n        }\r\n        let initialKeyframe = Array.isArray(value) ? value[0] : value;\r\n        /**\r\n         * If this is a number and we have a default value type, convert the number\r\n         * to this type.\r\n         */\r\n        const definition = transformDefinitions.get(key);\r\n        if (definition) {\r\n            initialKeyframe = isNumber(value)\r\n                ? definition.toDefaultUnit(value)\r\n                : value;\r\n        }\r\n        initialKeyframes[key] = initialKeyframe;\r\n    }\r\n    if (transformKeys.length) {\r\n        initialKeyframes.transform = buildTransformTemplate(transformKeys);\r\n    }\r\n    return initialKeyframes;\r\n}\r\n\r\nexport { createStyles };\r\n", "import { createStyles } from './style-object.es.js';\r\n\r\nconst camelLetterToPipeLetter = (letter) => `-${letter.toLowerCase()}`;\r\nconst camelToPipeCase = (str) => str.replace(/[A-Z]/g, camelLetterToPipeLetter);\r\nfunction createStyleString(target = {}) {\r\n    const styles = createStyles(target);\r\n    let style = \"\";\r\n    for (const key in styles) {\r\n        style += key.startsWith(\"--\") ? key : camelToPipeCase(key);\r\n        style += `: ${styles[key]}; `;\r\n    }\r\n    return style;\r\n}\r\n\r\nexport { createStyleString };\r\n", "import { animate as animate$1, withControls } from '@motionone/dom';\r\nimport { isFunction } from '@motionone/utils';\r\nimport { Animation } from '@motionone/animation';\r\n\r\nfunction animateProgress(target, options = {}) {\r\n    return withControls([\r\n        () => {\r\n            const animation = new Animation(target, [0, 1], options);\r\n            animation.finished.catch(() => { });\r\n            return animation;\r\n        },\r\n    ], options, options.duration);\r\n}\r\nfunction animate(target, keyframesOrOptions, options) {\r\n    const factory = isFunction(target) ? animateProgress : animate$1;\r\n    return factory(target, keyframesOrOptions, options);\r\n}\r\n\r\nexport { animate, animateProgress };\r\n"],
  "mappings": "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",
  "names": ["progress", "steps", "progress", "progress", "transforms", "data", "animate", "definition", "maxDuration", "defaults", "defaults", "defaults", "spring", "glide", "observer", "time", "defaultOffset", "hasChanged", "time", "controls", "listener", "time", "_a", "containerHandlers", "inView", "inView", "_a", "style", "animate"]
}
